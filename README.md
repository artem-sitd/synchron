## Сервис синхронизации файлов в локальной папке и удаленной облачной
Позволяет удалять файлы из облака, загружать файлы из локальной папки в облачную,
обновлять измененные файлы в заданный период времени
### Содержимое проекта:

* <u>.env.template</u> - содержит конфиденциальную информацию касающийся вашей
    * **OAuth_TOKEN**= спорный момент - пока что не придумал описания
    * **ClientID**= здесь укажите ваш токен ClientID (доступен по ссылке https://oauth.yandex.ru/)
    * **SELF_FOLDER**= укажите абсолютный путь до отслеживаемой папки
    * **CLOUD_FOLDER**= укажите папку в облаке для соединения её с вашей папкой на локальной машине
    * **PERIOD**= укажите период, когда будет выполняться запуск синхронизации (в секундах). Например, если в
      сценарии настроек вы укажите 300 - программа будет запускать синхронизацию каждые 300 секунд
    * **PATH_LOG**= укажите абсолютный путь до папки, где будет храниться файл лога
* <u>config.py</u> - подгрузка переменных из .env
* <u>hashwork.py</u> - создание, сравнение хэшей, сохранение в json
* <u>main.py</u> скрипт запуска программы
* <u>messages.py</u> - списки сообщений
* <u>settings.py</u> - сценарий для подготовки работы (опрос пользователя)
* <u>URLS.py</u> - перечень URL
* <u>yandex.py</u> - логика для работы с API yandexdisk.

### Этапы работы сервиса

1. После запуска main.py - пользовтелю необходимо выбрать прооводить или нет первоначальную настройку.
    2. Вариант с предварительной настройкой: пользователю будет необходимо указать `clientID`, `OAuth_TOKEN`, путь к
       локальной и удаленной папке, период обновлений (в секундах)
    3. Вариант без настройки просто начинает работу синхронизации
2. Первым этапом система получает перечень файлов в локальной и удаленной папках, сравнивая
   имена получает списки на удаление из облачной папки и список на
   добавление файлов (при отсутствии таких файлов в облаке).
3. Вторым этапом система формирует хээши имеющихся файлов в локальной папке и сравнивает
   их с хэшами файлов из предыдущего этапа синхронизации (если таковые имеются),
   при наличии разных хэшов у одинаковых файлов - система добавляет эти файлы в список на
   добавление в облако.
4. Применяет функии на удаление из облака, на загрузку в облако, а также сохраняет
   получившиеся хэши вместо старых в отдельные файлы json.
5. В планах внедрить систему логирования и возможно упаковать в десктоп приложение

### Проблемы

Согласно ТЗ:
> ● Чтобы обеспечить дальнейшее расширение программы для работы с другими файловыми сервисами, логика работы с
> конкретным облачным хранилищем должна быть вынесена в отдельный класс и файл. Конструктор этого класса должен
> принимать
> токен доступа и путь к существующей папке для хранения резервных копий в удалённом хранилище. Этот класс должен
> предоставлять методы:\
> ○ load(path) — для загрузки файла в хранилище;\
> ○ reload(path) — для перезаписи файла в хранилище;\
> ○ delete(filename) — для удаления файла из хранилища;\
> ○ get_info() — для получения информации о хранящихся в удалённом хранилище файлах.

Как я вижу реализацию: об использовании БД в ТЗ не указано, а это значит, что экземпляры
класса будут обнуляться после каждой остановки программы. В связи с чем при настройке программы (в случае если
пользователь в начале выбрал 1) входные данные сохраняются в аттрибуты класса, после завершения настроек эти атрибуты
записываются в .env.

Также планируется внедрить систему логирования с частичным выводом в консоль и отдельно в файл.

### Подробное описание логики функций и модулей:

* main.py - запускает программу
* settings.py - Перед пользователем встает выбор 
  * Если выбрать 1 - Начать работу с предварительной настройкой. Благодаря сообщениям не солжно догадаться
         какую информацию необходимо ввести - это `ClientID`(при создании приложения в API в яндекс
         диске оно указывается в разделе вашего приложения `https://oauth.yandex.ru/`), далее необходимо
         предоставить токен, который можно получить, посетив страницу, указанную в сообщении.
         Далее путь к локальным и облачным папкам и период обновления в секундах. По окончанию
         настроек начинается бесконечный цикл работы приложения командой user.update(), и прерывается командой
         time.sleep(указанный период.) По мере прохождения сценария заполняется экземляр класса
         YandexCloud, присваивая аттрибуты, и заполняя файл .env 
  * Если выбрать 2 - сразу начинает синхронизацию (при условии, что
         присутствуют переменные окружения), и создает экземпляр класса `YandexCloud`(аттрибуты
         заполняются из config)
         Модуль взаимодействует с модулями URLS, config(осуществляется подгрузка переменных
         окружения), yandex (там вся логика синхронизации), и messages (длинные сообщения для пользователя).

* URLS.py - содержит функции с URL для обращения к вашему облачному диску.
  * `get_token_url`
  * `get_headers` - headers для яндекса диска необходимо вставлять в каждый запрос
  * `get_token_url` - служит для получения токена при первичных настройках
  * `check_token_url` - для проверки соединения с интернетом, и проверки токена при настройках
  * `upload_get_delete_urls` - содержит url для удаления, загрузки файлов, проверки наличия указанной облачной папки
  * `check_available_url` - проверяет наличие соединения с интернетом и `timeout` при ожидании ответа от сервера
  
* config.py - загружает и хранит объекты переменных окружения
* messages.py - всего лишь длинные сообщения при настройках
* yandex.py активируется логика после обращения из settings.py `user1.update()`:
  1. получаем словарь локальных файлов (ключ - название файла, значение - его хэш) `dict_hash_local`, создаем файл,
  который будет хранить эти хэши `actual_hash.json`;
  2. получаем список файлов в облаке `cloud_files`;
  3. формируем множество `added_by_name` обращаясь к функции `compare_lists` - путем разности множеств локальных файлов и облачных (будет содержать файлы, 
  которых нет в облаке, сравнивая имена файлов);
  4. формируем множество `deleted_files` обращаясь к функции `compare_lists` - путем разности множеств облачных файлов и локальных (хранит в себе файлы, которые присутствуют
  в облаке, но отсутствуют в локальной папке);
  5. Если `deleted_files` не пустой - множество файлов отправляется в метод `delete`, где отправляется запрос на удаление переданных файлов;
  6. Если `added_by_name` не пустой - тогда из словаря `dict_hash_local` (пункт 1) удаляются эти файлы, сделано для того,
  чтобы разделить перечень файлов: новых и измененных;
  7. Далее получаем множество `added_by_hash`, получаемое из `hash_compare` (модуль hashwork). Путем сравнения их
  предыдущих хэшей, в случае если их хэши отличаются файл попадает в множество, в случае их соответствия - пропускается файл.
  Также при отсутствии информации о предыдущих хэшах - все переданные файлы возвращаются;
  8. Получаем объединение множеств `added_by_hash` | `added_by_name` и отправляем на загрузку в облако в методе `load`
  9. После загрузки - Удаляем старый файл, хранящий хэш, а новый переименовываем в старый